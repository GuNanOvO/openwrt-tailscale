name: Smaller Tailscale Build Pipeline

on:
  workflow_dispatch: 
  push:
    branches: [ main ]
    paths:
      - version
  repository_dispatch:
    types: [ build-tailscale ]

env:
  SOFTWARE_NAME: "Tailscale"
  FILE_NAME: "tailscaled"
  REPO: "tailscale/tailscale"
  REPO_SMALL: "GuNanOvO/openwrt-tailscale"
  REPO_SMALL_NAME: "openwrt-tailscale"
  REPO_SMALL_OWNER: "GuNanOvO"
  ARTIFACT_DIR: "artifacts"
  BUILD_DATE: ""

jobs:
  build:
    name: Build for ${{ matrix.platform }}
    runs-on: ubuntu-latest
    outputs:
      version: ${{ env.PKG_VERSION }}
    strategy:
      matrix:
        sdk:
          - 24.10.4
        platform:
          - 'aarch64_cortex-a53'
          - 'aarch64_cortex-a72'
          - 'aarch64_cortex-a76'
          - 'aarch64_generic'
          - 'arm_arm1176jzf-s_vfp'
          - 'arm_arm926ej-s'
          - 'arm_cortex-a15_neon-vfpv4'
          - 'arm_cortex-a5_vfpv4'
          - 'arm_cortex-a7'
          - 'arm_cortex-a7_neon-vfpv4'
          - 'arm_cortex-a7_vfpv4'
          - 'arm_cortex-a8_vfpv3'
          - 'arm_cortex-a9'
          - 'arm_cortex-a9_neon'
          - 'arm_cortex-a9_vfpv3-d16'
          - 'arm_fa526'
          - 'arm_xscale'
          - 'i386_pentium-mmx'
          - 'i386_pentium4'
          - 'loongarch64_generic'
          - 'mips64_mips64r2'
          - 'mips64_octeonplus'
          - 'mips64el_mips64r2'
          - 'mips_24kc'
          - 'mips_4kec'
          - 'mips_mips32'
          - 'mipsel_24kc'
          - 'mipsel_24kc_24kf'
          - 'mipsel_74kc'
          - 'mipsel_mips32'
          - 'riscv64_riscv64'
          - 'x86_64'
      fail-fast: true

    steps:
      - name: Checkout repository (develop branch)
        uses: actions/checkout@v4
        with:
          ref: develop
          path: repo

      - name: Prepare package
        run: |
          VERSION=$(sed -n 's/^PKG_VERSION:=\(.*\)/\1/p' repo/package/tailscale/Makefile | tr -d '[:space:]')
          RELEASE=$(sed -n 's/^PKG_COMMIT:=\(.*\)/\1/p' repo/package/tailscale/Makefile | tr -d '[:space:]')
          
          echo "PKG_VERSION=$VERSION" >> $GITHUB_ENV
          echo "PKG_COMMIT=$RELEASE" >> $GITHUB_ENV
          
          mkdir tailscale
          cp -r repo/package/tailscale/. tailscale/
          
          echo "Parsed version: $VERSION"
          echo "Parsed release: $RELEASE"

      # UPX 

      - name: Check UPX Latest Version
        id: check_upx
        run: |
          UPX_TAG=$(curl -s https://api.github.com/repos/upx/upx/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
          UPX_VER="${UPX_TAG#v}"
          echo "latest_tag=$UPX_TAG" >> $GITHUB_OUTPUT
          echo "latest_ver=$UPX_VER" >> $GITHUB_OUTPUT
          echo "Detected UPX Version: $UPX_TAG"

      - name: Cache UPX
        id: cache-upx
        uses: actions/cache@v4
        with:
          path: upx
          key: upx-linux-amd64-${{ steps.check_upx.outputs.latest_tag }}

      - name: Prepare UPX
        if: steps.cache-upx.outputs.cache-hit != 'true'
        env:
          UPX_TAG: ${{ steps.check_upx.outputs.latest_tag }}
          UPX_VER: ${{ steps.check_upx.outputs.latest_ver }}
        run: |
          UPX_URL="https://github.com/upx/upx/releases/download/${UPX_TAG}/upx-${UPX_VER}-amd64_linux.tar.xz"
          mkdir -p upx
          curl -L -o upx.tar.xz "$UPX_URL"
          tar -xf upx.tar.xz -C upx --strip-components=1
          chmod +x upx/upx

      - name: Verify UPX
        run: |
          ./upx/upx --version
          echo "UPX_BIN_PATH=$(pwd)/upx" >> $GITHUB_ENV
      
      # GO

      - name: Check Go Latest Version
        id: check_go
        run: |
          GO_VERSION=$(curl -s https://go.dev/VERSION?m=text | head -1)
          echo "latest_version=$GO_VERSION" >> $GITHUB_OUTPUT
          echo "Detected Go Version: $GO_VERSION"

      - name: Cache Go
        id: cache-go
        uses: actions/cache@v4
        with:
          path: go
          key: go-linux-amd64-${{ steps.check_go.outputs.latest_version }}

      - name: Prepare Go
        if: steps.cache-go.outputs.cache-hit != 'true'
        env:
          GO_VERSION: ${{ steps.check_go.outputs.latest_version }}
          GO_ARCH: amd64
          GO_OS: linux
        run: |
          GO_URL="https://go.dev/dl/${GO_VERSION}.${GO_OS}-${GO_ARCH}.tar.gz"
          mkdir -p go
          curl -L -o go.tar.gz "$GO_URL"
          tar -C go -xzf go.tar.gz --strip-components=1
          rm go.tar.gz

      - name: Verify Go
        run: |
          ./go/bin/go version
          echo "GO_BIN_PATH=$(pwd)/go" >> $GITHUB_ENV

      - name: Pull OpenWRT SDK Docker image
        run: |
          docker pull ghcr.io/openwrt/sdk:${{ matrix.platform }}-V${{ matrix.sdk }}

      # BUILD

      - name: Prepare build
        run: |
          mkdir -p bin
          mkdir -p "${{ env.ARTIFACT_DIR }}"
          chmod -R 777 bin || true
          ls -la

      - name: Build with OpenWRT SDK Docker
        run: |
          cat > build_script.sh << 'BUILD_SCRIPT_END'
          #!/bin/bash
          set -e
          cd /builder
          
          ./scripts/feeds update packages > /dev/null
          ./scripts/feeds install golang > /dev/null
          
          mkdir -p /builder/package/lang
          # ln -sf /builder/feeds/packages/lang/golang /builder/package/lang/golang
          
          rm -rf /builder/package/tailscale
          mkdir -p /builder/package/tailscale
          cp -r /builder/tailscale/. /builder/package/tailscale/
          
          make defconfig > /dev/null 2>&1

          [ -f /builder/go/bin/go ] || { echo "Error: Go binary missing"; exit 1; }
          
          mkdir -p /builder/staging_dir/hostpkg/bin
          ln -sf /builder/go/bin/go /builder/staging_dir/hostpkg/bin/go
          ln -sf /builder/go/bin/gofmt /builder/staging_dir/hostpkg/bin/gofmt
          
          if [ -d /builder/staging_dir/hostpkg/lib/go-cross/bin ]; then
            ln -sf /builder/go/bin/go /builder/staging_dir/hostpkg/lib/go-cross/bin/go
          fi
          
          echo "Using $(/builder/go/bin/go version)"
          
          make package/tailscale/compile V=s
          
          IPKS=$(find bin/packages bin/targets -name "tailscale_*.ipk" -type f)
          if [ -n "$IPKS" ]; then
            echo "Build Success:"
            ls -lh $IPKS
          else
            echo "Error: No IPK found" && exit 1
          fi
          BUILD_SCRIPT_END
          
          docker run --rm \
            -v "$(pwd)/bin:/builder/bin:z" \
            -v "$(pwd)/tailscale:/builder/tailscale:ro,z" \
            -v "${{ env.UPX_BIN_PATH }}:/builder/upx:ro,z" \
            -v "${{ env.GO_BIN_PATH }}:/builder/go:ro,z" \
            -v "$(pwd)/build_script.sh:/build_script.sh:ro,z" \
            -e TERM=xterm \
            -e FORCE=1 \
            ghcr.io/openwrt/sdk:${{ matrix.platform }}-V${{ matrix.sdk }} \
            bash /build_script.sh

      # UPLOAD

      - name: Collect build artifacts
        shell: bash
        run: |
          mkdir -p "${{ env.ARTIFACT_DIR }}"

          mapfile -t ipk_files < <(find bin -name "tailscale_*.ipk" -type f)

          if [ ${#ipk_files[@]} -eq 0 ]; then
            echo "::error::No IPK files found!"
            exit 1
          elif [ ${#ipk_files[@]} -gt 1 ]; then
            echo "::warning::Found multiple IPK files, picking the best match..."
          fi

          source_ipk="${ipk_files[0]}"
          ipk_dir=$(dirname "$source_ipk")
          
          target_ipk="${{ env.ARTIFACT_DIR }}/tailscale_${{ env.PKG_VERSION }}_${{ matrix.platform }}.ipk"
          target_packages="${{ env.ARTIFACT_DIR }}/Packages_${{ matrix.platform }}"

          echo "Moving and organizing artifacts..."
          
          cp -v "$source_ipk" "$target_ipk"

          if [ -f "$ipk_dir/Packages" ]; then
            echo "Found Packages file in $ipk_dir"
            cp -v "$ipk_dir/Packages" "$target_packages"
            
          else
            echo "::warning::Packages index file not found in $ipk_dir"
            find bin/packages -name "Packages" -exec cp {} "$target_packages" \; -quit
          fi

          if [ ! -s "$target_ipk" ]; then
            echo "::error::Artifact collection failed or IPK file is empty!"
            exit 1
          fi

          echo "Success: Artifacts ready in ${{ env.ARTIFACT_DIR }}"
          ls -lh "${{ env.ARTIFACT_DIR }}"


      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: tailscale_${{ env.PKG_VERSION }}_${{ matrix.platform }}
          path: ${{ env.ARTIFACT_DIR }}/
          if-no-files-found: error
          retention-days: 30

  # release:
  #   name: Create Release
  #   needs: [build]
  #   runs-on: ubuntu-latest
  #   env:
  #     RELEASE_TAG: v${{ needs.build.outputs.version }}
  #     VERSION: ${{ needs.build.outputs.version }}
  #     ARTIFACT_DIR: "release_assets"
  #   steps:
  #     - name: Prepare workspace
  #       run: mkdir -p ${{ env.ARTIFACT_DIR }}

  #     - name: Download artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         path: temp_artifacts

  #     - name: Organize and Generate Files
  #       run: |
  #         echo "BUILD_DATE=$(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV
          
  #         INFO_FILE="${{ env.ARTIFACT_DIR }}/build-info.txt"
  #         JSON_FILE="${{ env.ARTIFACT_DIR }}/artifacts.json"
          
  #         {
  #           echo "Version: v${{ needs.build.outputs.pkg_version }}"
  #           echo "Build date: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
  #           echo ""
  #           echo "File sizes:"
  #         } > "$INFO_FILE"
          
  #         echo "[" > "$JSON_FILE"
          
  #         first=true
  #         for dir in temp_artifacts/*/; do
  #           [ -d "$dir" ] || continue
            
  #           ipk_path=$(find "$dir" -name "*.ipk" -type f | head -n 1)
  #           [ -z "$ipk_path" ] && continue
            
  #           ipk_name=$(basename "$ipk_path")
  #           filename_no_ext="${ipk_name%.ipk}"
  #           arch=$(echo "$filename_no_ext" | rev | cut -d'_' -f1 | rev)
            
  #           cp "$ipk_path" "${{ env.ARTIFACT_DIR }}/"
            
  #           size_val="Unknown"
  #           [ -f "${dir}size" ] && size_val=$(cat "${dir}size")
            
  #           echo "${filename_no_ext} ${size_val} bytes" >> "$INFO_FILE"
            
  #           # 4. å†™å…¥ artifacts.json
  #           if [ "$first" = true ]; then
  #             first=false
  #           else
  #             echo "," >> "$JSON_FILE"
  #           fi
  #           echo "{\"target\":\"${arch}\",\"ipk\":\"${ipk_name}\"}" >> "$JSON_FILE"
  #         done
          
  #         echo "]" >> "$JSON_FILE"

  #     - name: Create Checksums
  #       run: |
  #         cd ${{ env.ARTIFACT_DIR }}
  #         sha256sum *.ipk > checksums.txt

  #     - name: Create GitHub Release
  #       uses: softprops/action-gh-release@v1
  #       with:
  #         tag_name: ${{ env.RELEASE_TAG }}
  #         files: |
  #           ${{ env.ARTIFACT_DIR }}/*.ipk
  #           ${{ env.ARTIFACT_DIR }}/checksums.txt
  #           ${{ env.ARTIFACT_DIR }}/build-info.txt
  #           ${{ env.ARTIFACT_DIR }}/artifacts.json
      
  #     - name: Checkout feed branch
  #       uses: actions/checkout@v4
  #       with:
  #         ref: feed
  #         path: feed
      
  #     - name: Setup Usign
  #       run: |
  #         git clone https://git.openwrt.org/project/usign.git
  #         cd usign
  #         mkdir build
  #         cd build
  #         cmake ..
  #         make
  #         make install
          
  #     - name: Restore usign private key
  #       env:
  #         USIGN_SECRET_KEY_B64: ${{ secrets.USIGN_SECRET_KEY_B64 }}
  #       shell: bash
  #       run: |
  #         echo "$USIGN_SECRET_KEY_B64" | base64 -d > key-build.sec
  #         chmod 600 key-build.sec
          
  #     - name: Prepare feed files
  #       run: |
  #         rm -rf feed/tailscale* feed/Packages* feed/version*
                
  #         # Copy all IPK files from artifacts
  #         find ${{ env.ARTIFACT_DIR }} -name "tailscale_*.ipk" -exec cp {} feed/ \; 2>/dev/null || true

  #         # Try to generate package index if opkg-utils is available
  #         if command -v opkg-make-index &> /dev/null; then
  #           cd feed
  #           opkg-make-index -a -f -v --checksum sha256 . > Packages 2>&1 || echo "Failed to generate package index, continuing..."
  #           gzip -kf Packages
  #           cd ..
  #         else
  #           echo "opkg-utils not available, skipping package index generation"
  #         fi
              
  #         ls -lh feed/ || true
          
  #         [ -f feed/Packages ] && file feed/Packages || true
  #         [ -f key-build.sec ] && file key-build.sec || true

  #         if [ -f feed/Packages ] && [ -f key-build.sec ]; then
  #           usign -S -m feed/Packages -s key-build.sec -x feed/Packages.sig || echo "Signing failed, continuing..."
  #           [ -f feed/Packages.sig ] && cat feed/Packages.sig || true
  #         fi
          
  #         generate_tbody() {
  #           echo "          <tbody>"
  #           for file in feed/Packages* feed/tailscale*; do
  #             [ -f "${file}" ] || continue
  #             fname=$(basename "${file}")
  #             fsize=$(du -h "${file}" | cut -f1)
  #             fdate=$(date -r "${file}" +"%Y-%m-%d %a %H:%M:%S UTC")
  #             echo "                        <tr>"
  #             echo "                            <td><a href=\"$fname\">$fname</a></td>"
  #             echo "                            <td>$fsize</td>"
  #             echo "                            <td>$fdate</td>"
  #             echo "                        </tr>"
  #           done
  #           echo "          </tbody>"
  #         }

  #         generate_tbody > feed/tbody.tmp
  #         sed -i '/<!-- tbody-anchor -->/,/<!-- end-tbody-anchor -->/ {
  #           /<!-- tbody-anchor -->/!{
  #             /<!-- end-tbody-anchor -->/!d
  #           }
  #         }' feed/index.html
  #         sed -i '/<!-- tbody-anchor -->/r feed/tbody.tmp' feed/index.html

  #         current_date="${{ env.BUILD_DATE }}"
  #         sed -i '/<!-- date-anchor -->/,/<!-- end-date-anchor -->/ {
  #             /<span id="date">/ {
  #                 s#<span id="date">.*</span>#<span id="date">'"${current_date}"'</span>#
  #             }
  #         }' feed/index.html

  #         version=$(echo "${{ env.RELEASE_TAG }}" | sed 's/^v//')
  #         sed -i '/<!-- version-anchor -->/,/<!-- end-version-anchor -->/ {
  #             /<span id="version">/ {
  #                 s#<span id="version">.*</span>#<span id="version">'"${version}"'</span>#
  #             }
  #         }' feed/index.html
  #         rm -f feed/tbody.tmp

  #     - name: Commit and push to feed branch
  #       run: |
  #         git config --local user.email "action@github.com"
  #         git config --local user.name "GitHub Action"
  #         git add -A
  #         git diff --cached --quiet && echo "No changes" && exit 0
  #         git commit -m "Update feed: ${{ env.BUILD_DATE }}"
  #         git push origin HEAD:feed
  #       working-directory: feed

  #     - name: Generate release markdown
  #       id: generate_release_markdown
  #       run: |
  #         # Read artifacts.json and generate markdown table
  #         artifacts_file="${{ env.ARTIFACT_DIR }}/artifacts.json"
          
  #         if [[ ! -f "${artifacts_file}" ]]; then
  #           echo "No artifacts.json found, skipping table generation."
  #           exit 1
  #         fi
          
  #         # Generate Markdown table for IPK files only
  #         owner="${{ env.REPO_SMALL_OWNER }}"
  #         repo="${{ env.REPO_SMALL_NAME }}"
  #         tag="${{ env.RELEASE_TAG }}"
  #         table="| Target Platform ç›®æ ‡å¹³å° | IPK Package |
  #         |----------------------|------------|
  #         $(jq -r --arg owner "$owner" --arg repo "$repo" --arg tag "$tag" '
  #         .[] | 
  #         "| \(.target) | [\(.ipk)](https://github.com/\($owner)/\($repo)/releases/download/\($tag)/\(.ipk)) |"
  #         ' ${artifacts_file})"

  #         # Print the table for debugging
  #         echo "$table"

  #         # Set release body with table included
  #         release_body="## ğŸš€ Smaller Tailscale / æ›´å°çš„Tailscale

  #         **Version ç‰ˆæœ¬** :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ${{ env.RELEASE_TAG }}   
  #         **Build date æ„å»ºæ—¥æœŸ** : &nbsp;&nbsp;&nbsp;&nbsp;${{ env.BUILD_DATE }}   
  #         **Changelog æ›´æ–°æ—¥å¿—** : &nbsp;&nbsp;&nbsp;https://github.com/${{ env.REPO }}/releases/tag/${{ env.RELEASE_TAG }}   

  #         ---

  #         ### ğŸŒ ä¸­æ–‡è¯´æ˜
  #         <details>
  #         <summary>ç‚¹å‡»å±•å¼€</summary>
  #         è¿™æ˜¯ä¸€ä¸ªä¸º OpenWRT æ„å»ºçš„ Tailscale çš„æç®€ç‰ˆæœ¬ï¼Œä½¿ç”¨ OpenWRT å®˜æ–¹ SDK ç¼–è¯‘ï¼Œæ—¨åœ¨æä¾›æ›´å°çš„äºŒè¿›åˆ¶æ–‡ä»¶å’Œæ›´å°‘çš„èµ„æºå ç”¨ã€‚åŒ…å« IPK åŒ…ï¼Œé€‚ç”¨äºå¤šç§ OpenWRT ç›®æ ‡å¹³å°ã€‚

  #         ### ğŸ› ï¸ æ„å»ºç‰¹æ€§
  #         - ä½¿ç”¨ OpenWRT å®˜æ–¹ SDK è¿›è¡Œç¼–è¯‘
  #         - Tailscale ä½¿ç”¨ç²¾ç®€çš„ TAGS ä¸ LDFLAGS ç¼–è¯‘
  #         - ä½¿ç”¨ UPX å‹ç¼©æŠ€æœ¯å¯¹äºŒè¿›åˆ¶æ–‡ä»¶è¿›è¡Œå‹ç¼©ï¼ˆæŸäº›æ¶æ„é™¤å¤–ï¼‰ï¼Œå¤§å¹…å‡å° IPK ä½“ç§¯
  #         - å®Œæ•´çš„ IPK åŒ…æ ¼å¼ï¼Œå¯ç›´æ¥é€šè¿‡ opkg å®‰è£…

  #         ### âš ï¸ ç³»ç»Ÿéœ€æ±‚
  #         - **å­˜å‚¨ç©ºé—´**: IPK æ–‡ä»¶é€šå¸¸å°äº 10MB
  #         - **è¿è¡Œå†…å­˜**: å¤§çº¦ 60MB
  #         - **æ³¨æ„äº‹é¡¹**: å¯èƒ½æ— æ³•åœ¨å†…å­˜å°äº 256MB çš„è®¾å¤‡ä¸Šæ­£å¸¸è¿è¡Œï¼Œè¯·è°¨æ…ä½¿ç”¨ã€‚

  #         ### ğŸ“– å¦‚ä½•ç¡®å®šç›®æ ‡å¹³å°
  #         åœ¨æ‚¨çš„ OpenWRT è®¾å¤‡ä¸Šè¿è¡Œä»¥ä¸‹å‘½ä»¤ä»¥ç¡®å®šæ”¯æŒçš„ç›®æ ‡å¹³å°ï¼š
  #         \`\`\`bash
  #         opkg print-architecture
  #         \`\`\`
  #         è¯¥å‘½ä»¤å°†åˆ—å‡ºè®¾å¤‡æ”¯æŒçš„æ¶æ„ç±»å‹ï¼ˆä¸åŒ…æ‹¬ \`all\` å’Œ \`noarch\`ï¼‰ã€‚æ ¹æ®è¾“å‡ºç»“æœé€‰æ‹©å¯¹åº”çš„æ–‡ä»¶è¿›è¡Œå®‰è£…ã€‚

  #         ### ğŸ“¦ å®‰è£…æ–¹æ³•
  #         \`\`\`bash
  #         opkg install tailscale_X.XX.X_<your_architecture>.ipk
  #         \`\`\`

  #         </details>

  #         ### ğŸŒ English Description
  #         <details>
  #         <summary>Click to expand</summary>
  #         This is a minimal build of Tailscale for OpenWRT, compiled using the official OpenWRT SDK, designed to provide smaller binaries and lower resource usage. It includes IPK packages for various OpenWRT target platforms.

  #         ### ğŸ› ï¸ Build Features
  #         - Compiled using the official OpenWRT SDK
  #         - Tailscale uses streamlined TAGS and LDFLAGS for compilation
  #         - UPX compression applied to binaries (except for some architectures) to significantly reduce IPK size
  #         - Complete IPK package format, can be installed directly via opkg

  #         ### âš ï¸ System Requirements
  #         - **Storage Space**: IPK files are typically less than 10MB
  #         - **RAM**: Approximately 60MB
  #         - **Note**: May not work on devices with less than 256MB of RAM. Use with caution.

  #         ### ğŸ“– How to Determine the Target Platform
  #         Run the following command on your OpenWRT device to determine the supported target platform:
  #         \`\`\`bash
  #         opkg print-architecture
  #         \`\`\`
  #         This command will list the supported architecture types (excluding \`all\` and \`noarch\`). Choose the corresponding file based on the output.

  #         ### ğŸ“¦ Installation Method
  #         \`\`\`bash
  #         opkg install tailscale_X.XX.X_<your_architecture>.ipk
  #         \`\`\`

  #         </details>

  #         ---

  #         > [!WARNING]
  #         > å¦‚æœ \`opkg\` å®‰è£…æ˜¾ç¤ºå®‰è£…å¤±è´¥ï¼Œè¯·å…ˆé€šè¿‡è¿è¡Œä»¥ä¸‹å‘½ä»¤æµ‹è¯•ï¼š
  #         > \`\`\`bash
  #         > tailscale --version
  #         > \`\`\`
  #         > å¦‚æœå‘½ä»¤æ­£ç¡®è¾“å‡ºç‰ˆæœ¬å·ï¼Œåˆ™å®‰è£…æˆåŠŸã€‚å¦åˆ™è¯·æäº¤åé¦ˆã€‚
  #         >
  #         > If the \`opkg\` installation shows failure, please test first by running:
  #         > \`\`\`bash
  #         > tailscale --version
  #         > \`\`\`
  #         > If the command correctly outputs the version number, the installation is successful. Otherwise, please submit feedback.

  #         ---

  #         ### ğŸ“¥ Download Links List / ä¸‹è½½é“¾æ¥æ¸…å•
  #         > [!NOTE]
  #         > è¯·ç¡®ä¿é€‰æ‹©æ­£ç¡®çš„ç›®æ ‡å¹³å°æ¶æ„å’Œ Tailscale ç‰ˆæœ¬ã€‚
  #         > Make sure to select the correct target platform architecture and Tailscale version.
  #         <details>
  #         <summary>Click to expand  /  ç‚¹å‡»å±•å¼€</summary>

  #         ${table}

  #         </details>
  #         "

  #         echo "release_body<<EOF" >> $GITHUB_OUTPUT
  #         echo "${release_body}" >> $GITHUB_OUTPUT
  #         echo "EOF" >> $GITHUB_OUTPUT

  #     - name: Create GitHub Release
  #       uses: softprops/action-gh-release@v1
  #       with:
  #         tag_name: ${{ env.RELEASE_TAG }}
  #         name: "Smaller ${{ env.SOFTWARE_NAME }} ${{ env.RELEASE_TAG }}"
  #         body: ${{ steps.generate_release_markdown.outputs.release_body }}
  #         files: |
  #           ${{ env.ARTIFACT_DIR }}/*.ipk
  #           ${{ env.ARTIFACT_DIR }}/checksums.txt
  #           ${{ env.ARTIFACT_DIR }}/build-info.txt


  #     - name: Sync to small repo
  #       uses: actions/github-script@v6
  #       with:
  #         script: |
  #           await github.rest.git.createTag({
  #             owner: '${{ env.REPO_SMALL_OWNER }}',
  #             repo: 'openwrt-tailscale',
  #             tag: '${{ env.RELEASE_TAG }}',
  #             message: 'Release ${{ env.RELEASE_TAG }}',
  #             object: '${{ github.sha }}',
  #             type: 'commit'
  #           })