name: Daily Tailscale GHCR Check

permissions:
  contents: read

on:
  schedule:
    - cron: '0 4,8,18,22 * * *'
  workflow_dispatch:
    inputs:
      version_check_method:
        description: 'Version check method to use'
        type: choice
        options:
          - ghcr
          - tag
        default: 'ghcr'
        required: true

jobs:
  version-check:
    name: Check Version Differences
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.compare.outputs.should_build }}
      selected_version: ${{ steps.compare.outputs.selected_version }}
      check_method: ${{ steps.compare.outputs.check_method }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Load check method from .config/check-method
        id: load-method
        run: |
          # 优先使用 workflow_dispatch 输入，其次读取配置文件，最后默认 ghcr
          if [ -n "${{ github.event.inputs.version_check_method }}" ]; then
            method="${{ github.event.inputs.version_check_method }}"
            echo "Using manually provided method: $method"
          elif [ -f .config/check-method ]; then
            method=$(cat .config/check-method | tr -d '[:space:]')
            echo "Using method from .config/check-method: $method"
          else
            method="ghcr"
            echo "Using default method: $method"
          fi

          # 输出给后续步骤使用
          echo "method=$method" >> $GITHUB_OUTPUT

      - name: Get GHCR stable version
        id: get_ghcr
        uses: actions/github-script@v6
        env:
          GHCR_TOKEN: ${{ secrets.GHCR_READ_TOKEN }}
        with:
          script: |
            const token = process.env.GHCR_TOKEN;
            const res = await fetch(
              'https://api.github.com/orgs/tailscale/packages/container/tailscale/versions',
              { headers: { 
                  'Authorization': `Bearer ${token}`,
                  'Accept': 'application/vnd.github.v3+json'
                } 
              }
            );
            const versions = await res.json();

            const latestStableObj = versions.find(v => {
              const tags = v.metadata.container.tags || [];
              return tags.includes('stable') && tags.includes('latest');
            });

            if (!latestStableObj) throw new Error('No version found with both stable and latest tags');

            const versionTag = (latestStableObj.metadata.container.tags || [])
              .filter(tag => tag !== 'latest' && tag !== 'stable')[0];

            if (!versionTag) throw new Error('No version tag found');

            console.log('Upstream latest stable version tag:', versionTag);
            core.setOutput('stable_version', versionTag);

      - name: Get latest tag from release
        id: get_tag_release
        uses: actions/github-script@v6
        with:
          script: |
            const { data: tags } = await github.rest.repos.listTags({
              owner: 'tailscale',
              repo: 'tailscale',
              per_page: 100
            });

            const stableTags = tags
              .map(tag => tag.name)
              .filter(name => /^v\d+\.\d+\.\d+$/.test(name));

            stableTags.sort((a, b) => {
              const parse = v => v.slice(1).split('.').map(Number);
              const [a1, a2, a3] = parse(a);
              const [b1, b2, b3] = parse(b);
              return b1 - a1 || b2 - a2 || b3 - a3;
            });

            const latest = stableTags[0] || '';
            core.setOutput('tag', latest);

      - name: Get latest release tag from openwrt-tailscale
        id: get_small
        uses: actions/github-script@v6
        with:
          script: |
            try {
              const { data } = await github.rest.repos.getLatestRelease({
                owner: 'GuNanOvO',
                repo: 'openwrt-tailscale'
              });
              core.setOutput('tag', data?.tag_name || '');
            } catch (error) {
              core.setOutput('tag', '');
            }

      - name: Compare versions
        id: compare
        run: |
          check_method="${{ steps.load-method.outputs.method }}"
          echo "Using version check method: $check_method"
          
          if [ "$check_method" = "ghcr" ]; then
            echo "GHCR Upstream Version: ${{ steps.get_ghcr.outputs.stable_version }}"
            echo "Local Version: ${{ steps.get_small.outputs.tag }}"
            
            if [ "${{ steps.get_ghcr.outputs.stable_version }}" != "${{ steps.get_small.outputs.tag }}" ]; then
              echo "New version found in GHCR"
              echo "should_build=true" >> ${GITHUB_OUTPUT}
              echo "selected_version=${{ steps.get_ghcr.outputs.stable_version }}" >> ${GITHUB_OUTPUT}
              echo "check_method=ghcr" >> ${GITHUB_OUTPUT}
            else
              echo "No new version found in GHCR"
              echo "should_build=false" >> ${GITHUB_OUTPUT}
            fi
          else
            echo "Tag Release Version: ${{ steps.get_tag_release.outputs.tag }}"
            echo "Local Version: ${{ steps.get_small.outputs.tag }}"
            
            if [ "${{ steps.get_tag_release.outputs.tag }}" != "${{ steps.get_small.outputs.tag }}" ]; then
              echo "New version found in tag release"
              echo "should_build=true" >> ${GITHUB_OUTPUT}
              echo "selected_version=${{ steps.get_tag_release.outputs.tag }}" >> ${GITHUB_OUTPUT}
              echo "check_method=tag" >> ${GITHUB_OUTPUT}
            else
              echo "No new version found in tag release"
              echo "should_build=false" >> ${GITHUB_OUTPUT}
            fi
          fi


  trigger-build:
    name: Trigger Build Workflow with Commit
    permissions:
      contents: write
    needs: version-check
    if: needs.version-check.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    outputs:
      ghcr_commit: ${{ steps.get_commit.outputs.commit }}
    steps:
      - name: Get commit based on selected method
        id: get_commit
        run: |
          check_method="${{ needs.version-check.outputs.check_method }}"
          version="${{ needs.version-check.outputs.selected_version }}"
          echo "Using method: $check_method with version: $version"
          
          if [ "$check_method" = "ghcr" ]; then
            echo "Getting commit from GHCR version ${version}"
            docker pull ghcr.io/tailscale/tailscale:${version}
            commit=$(docker run --rm ghcr.io/tailscale/tailscale:${version} tailscale version | grep -oP 'tailscale commit: \K\w+')
            if [ -n "$commit" ]; then
              echo "Commit from GHCR: $commit"
              echo "commit=$commit" >> $GITHUB_OUTPUT
              echo "version=$version" >> $GITHUB_OUTPUT
              exit 0
            fi
          else
            echo "Getting commit from tag release $version"
            git ls-remote https://github.com/tailscale/tailscale.git refs/tags/${version} | cut -f1 > tag_commit.txt
            commit=$(cat tag_commit.txt)
            if [ -n "$commit" ]; then
              echo "Commit from tag: $commit"
              echo "commit=$commit" >> $GITHUB_OUTPUT
              echo "version=$version" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          echo "Failed to get commit using $check_method method"
          exit 1

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Commit and push new version file
        id: push_new_version
        run: |
          echo "UPSTREAM_COMMIT: ${{ steps.get_commit.outputs.commit }}" > version
          echo "VERSION: ${{ steps.get_commit.outputs.version}}" >> version
          git config --local user.name "action@github.com"
          git config --local user.email "GitHub Action"
          git add version
          git commit -m "chore: update version to ${{ steps.get_commit.outputs.commit }} [CI-BUILD-NEW-VERSION]" || true
          git push origin main

      - name: Trigger build workflow
        uses: peter-evans/repository-dispatch@v4
        with:
          event-type: build-trigger
          token: ${{ secrets.PAT_TOKEN }}